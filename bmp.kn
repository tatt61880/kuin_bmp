{{{
	bmp.kn
		Last Modified: 2017/01/11 01:05:01.
		Created by Tatt(@tatt61880)
		https://twitter.com/tatt61880
		https://github.com/tatt61880
}}}

func new(width: int, height: int): @Image
	ret (#@Image).new(width, height)
end func

+func load(path: []char): @Image
	ret (#@Image).load(path)
end func

+class Image()
	var width: int
	var height: int
	var data: [][]@Rgba

	+func new(width: int, height: int): @Image
		do me.width :: width
		do me.height :: height
		do me.data :: #[me.height][]@Rgba
		var white: @Rgba :: (#@Rgba).init(255b8, 255b8, 255b8, 255b8)
		for y(0, me.height - 1)
			do me.data[y] :: #[me.width]@Rgba
			for x(0, me.width - 1)
				do me.data[y][x] :: ##white
			end for
		end for
		ret me
	end func

	+func load(path: []char): @Image
		if((#Bmp).isBmp(path))
			var bmp: Bmp :: (#Bmp).load(path)
			do me.width :: bmp.getWidth()
			do me.height :: bmp.getHeight()
			do me.data :: bmp.getData()
		else
			do cui@print("[bmp.kn] Windows用のBMP形式画像（マジックナンバー=BM）以外には未対応です。\n")
			assert false
		end if
		ret me
	end func

	+func save(path: []char, type: @Filetype): bool
		switch(type)
		case(@Filetype#bmp24bit)
			ret (#Bmp).save(me, path, type)
		end switch
		ret false
	end func

	class Bmp()
		var width: int
		var height: int
		var data: [][]@Rgba

		var bmph: BitmapFileHeader
		var dibh: DibHeader
		var palette: []@Rgba

		+func load(path: []char): Bmp
			var stream: file@Reader :: file@makeReader(path)
			if(stream =& null)
				ret null
			end if
			do me.bmph :: (#BitmapFileHeader).read(stream)
			do me.dibh :: (#DibHeader).read(stream)
			do me.width :: me.dibh.width
			do me.height :: me.dibh.height

			{streamからカラーパレットを読み込む}
			switch bpp(me.dibh.getBpp())
			case 1, 2, 4, 8, 16
				do me.palette :: #[2 ^ bpp]@Rgba
				for i(0, 2^bpp - 1)
					do me.palette[i] :: #@Rgba
					do me.palette[i].b :: stream.read(1)[0]
					do me.palette[i].g :: stream.read(1)[0]
					do me.palette[i].r :: stream.read(1)[0]
					do me.palette[i].a :: 255 $ bit8
					do stream.read(1)
				end for
			case(24)
			case(32)
			default
				do cui@print("[bmp.kn] 1ピクセルあたりのビット数(bpp: bit per pixel)が異常です。\n")
				assert false
			end switch

			{streamからbitmapを読み込む}
			do me.data :: #[me.height][]@Rgba
			for y(0, me.height - 1)
				do me.data[y] :: #[me.width]@Rgba
				for x(0, me.width - 1)
					do me.data[y][x] :: #@Rgba
				end for
			end for

			var xSize: int :: me.width * me.dibh.getBpp() / 8 + 3
			do xSize :- xSize % 4

			switch bpp(me.dibh.getBpp())
			case(1)
				for y(0, me.height - 1)
					var bin: []bit8 :: stream.read(xSize)
					for x(0, me.width - 1)
						do me.data[y][x] :: me.palette[bin[x / 8].shr(7 - x % 8).and(1 $ bit8) $ int]
					end for
				end for
			case(2)
				for y(0, me.height - 1)
					var bin: []bit8 :: stream.read(xSize)
					for x(0, me.width - 1)
						do me.data[y][x] :: me.palette[bin[x / 4].shr((3 - x % 4) * 2).and(3 $ bit8) $ int]
					end for
				end for
			case(4)
				for y(0, me.height - 1)
					var bin: []bit8 :: stream.read(xSize)
					for x(0, me.width - 1)
						do me.data[y][x] :: me.palette[bin[x / 2].shr((1 - x % 2) * 4).and(15 $ bit8) $ int]
					end for
				end for
			case(8)
				for y(0, me.height - 1)
					var bin: []bit8 :: stream.read(xSize)
					for x(0, me.width - 1)
						do me.data[y][x] :: me.palette[bin[x] $ int]
					end for
				end for
			case(16)
				for y(0, me.height - 1)
					var bin: []bit8 :: stream.read(xSize)
					for x(0, me.width - 1)
						do me.data[y][x] :: me.palette[bin[2 * x] $ int + bin[2 * x + 1] $ int * 255]
					end for
				end for
			case(24)
				for y(0, me.height - 1)
					var bin: []bit8 :: stream.read(xSize)
					for x(0, me.width - 1)
						do me.data[y][x].b :: bin[3 * x + 0]
						do me.data[y][x].g :: bin[3 * x + 1]
						do me.data[y][x].r :: bin[3 * x + 2]
						do me.data[y][x].a :: 255 $ bit8 {不透明}
					end for
				end for
			case(32)
				for y(0, me.height - 1)
					var bin: []bit8 :: stream.read(xSize)
					for x(0, me.width - 1)
						do me.data[y][x].b :: bin[4 * x + 0]
						do me.data[y][x].g :: bin[4 * x + 1]
						do me.data[y][x].r :: bin[4 * x + 2]
						do me.data[y][x].a :: bin[4 * x + 3]
					end for
				end for
			default
				do cui@print("[bmp.kn] 1ピクセルあたりのビット数(bpp: bit per pixel)が異常です。\n")
				assert false
			end switch

			ret me
		end func

		+func save(img: @Image, path: []char, type: @Filetype): bool
			var stream: file@Writer :: file@makeWriter(path, false)
			if(stream =& null)
				ret false
			end if
			switch(type)
			case(@Filetype#bmp24bit)
				var xSize: int :: 3 * img.getWidth() + 3
				do xSize :- xSize % 4
				var filesize: int :: 14 + 40 + xSize * img.getHeight()
				var bin: []bit8 :: #[filesize]bit8
				do bin[0] :: 'B' $ bit8
				do bin[1] :: 'M' $ bit8
				var binFilesize: []bit8 :: filesize.toBin()
				do bin[2] :: binFilesize[0]
				do bin[3] :: binFilesize[1]
				do bin[4] :: binFilesize[2]
				do bin[5] :: binFilesize[3]
				do bin[10] :: 54b8 {ファイル先頭からデータ先頭までのオフセット}
				do bin[14] :: 40b8 {情報ヘッダのサイズ}
				var binWidth: []bit8 :: img.getWidth().toBin()
				var binHeight: []bit8 :: img.getHeight().toBin()
				do bin[18] :: binWidth[0]
				do bin[19] :: binWidth[1]
				do bin[20] :: binWidth[2]
				do bin[21] :: binWidth[3]
				do bin[22] :: binHeight[0]
				do bin[23] :: binHeight[1]
				do bin[24] :: binHeight[2]
				do bin[25] :: binHeight[3]
				do bin[26] :: 1b8
				do bin[28] :: 24b8 {bpp}
				var binDatasize: []bit8 :: (xSize * img.getHeight()).toBin()
				do bin[34] :: binDatasize[0]
				do bin[35] :: binDatasize[1]
				do bin[36] :: binDatasize[2]
				do bin[37] :: binDatasize[3]
				do bin[38] :: 16#C4b8 {水平解像度}
				do bin[39] :: 16#0Eb8 {水平解像度}
				do bin[42] :: 16#C4b8 {垂直解像度}
				do bin[43] :: 16#0Eb8 {垂直解像度}
				var p: @Rgba
				var offset: int
				for y(0, img.getHeight() - 1)
					for x(0, img.getWidth() - 1)
						do p :: img.getPixel(x, y)
						do offset :: 14 + 40 + xSize * y + 3 * x
						do bin[offset + 0] :: p.b
						do bin[offset + 1] :: p.g
						do bin[offset + 2] :: p.r
					end for
				end for
				do stream.write(bin)
				ret true
			default
				{
				do stream.writeStr("[bmp.kn] 指定されたファイル形式での保存は未実装です。") {TODO}
				}
				do cui@print("[bmp.kn] 指定されたファイル形式での保存は未実装です。")
				ret false
			end switch
		end func

		+func getWidth(): int
			ret me.width
		end func

		+func getHeight(): int
			ret me.height
		end func

		+func getData(): [][]@Rgba
			ret me.data
		end func

		class BitmapFileHeader()
			var id: []bit8
			var filesize: int
			var reserved1: []bit8
			var reserved2: []bit8
			var offset: int

			+func read(stream: file@Reader): BitmapFileHeader
				do stream.setPos(file@Origin#head, 0)
				do me.id :: stream.read(2)
				do me.filesize.fromBin(stream.read(4) ~ #[4]bit8, 0)
				do me.reserved1 :: stream.read(2)
				do me.reserved2 :: stream.read(2)
				do me.offset.fromBin(stream.read(4) ~ #[4]bit8, 0)
				{
				do cui@print("[bmp.kn] filesize = " ~ (me.filesize).toStr() ~ "byte\n")
				}
				ret me
			end func
		end class

		class DibHeader()
			var meHeaderSize: int
			+var width: int
			+var height: int
			var planeNum: int
			var bpp: int
			var compressMethod: CompressMethod
			var imgSize: int
			var horResolution: int
			var colResolution: int
			var colorNum: int
			var importantColor: int
			+func read(stream: file@Reader): DibHeader
				{
				do cui@print("[bmp.kn] ※Tell() = 0x" ~ stream.Tell().ToStrF("x") ~ "\n")
				}
				do me.meHeaderSize.fromBin(stream.read(4) ~ #[4]bit8, 0)
				if(me.meHeaderSize <> 40)
					do cui@print("[bmp.kn] BITMAPINFOHEADER以外の情報ヘッダを持つBMP画像には未対応です。\n")
					do cui@print("[bmp.kn] ヘッダサイズ: " ~ me.meHeaderSize.toStr() ~ "\n")
					assert false
				end if
				do me.width.fromBin(stream.read(4) ~ #[4]bit8, 0)
				do me.height.fromBin(stream.read(4) ~ #[4]bit8, 0)
				{
				do cui@print("[bmp.kn] width = " ~ me.width.toStr() ~ ", height = " ~ me.height.toStr() ~ "\n")
				}
				do me.planeNum.fromBin(stream.read(2) ~ #[6]bit8, 0)
				do me.bpp.fromBin(stream.read(2) ~ #[6]bit8, 0)
				do me.compressMethod.fromBin(stream.read(4) ~ #[4]bit8, 0)
				if(me.compressMethod <> CompressMethod#BI_RGB)
					do cui@print("[bmp.kn] BI_RGB以外の圧縮形式のBMP画像には未対応です。\n")
					assert false
				end if
				do me.imgSize.fromBin(stream.read(4) ~ #[4]bit8, 0)
				do me.horResolution.fromBin(stream.read(4) ~ #[4]bit8, 0)
				do me.colResolution.fromBin(stream.read(4) ~ #[4]bit8, 0)
				do me.colorNum.fromBin(stream.read(4) ~ #[4]bit8, 0)
				do me.importantColor.fromBin(stream.read(4) ~ #[4]bit8, 0)
				{
				do cui@print("[bmp.kn] bpp = " ~ (me.bpp).toStr() ~ "\n")
				}

				ret me
			end func

			+func getBpp(): int
				ret me.bpp
			end func

			enum CompressMethod
				BI_RGB
				BI_RLE8
				BI_RLE4
				BI_BITFIELDS
				BI_JPEG
				BI_PNG
				BI_ALPHABITFIELDS
			end enum
		end class

		+func isBmp(path: []char): bool
			var stream: file@Reader :: file@makeReader(path)
			var id: []bit8 :: stream.read(2)
			ret ((id[0] $ char) = 'B' & (id[1] $ char) = 'M')
		end func
	end class

	+func getWidth(): int
		ret me.width
	end func

	+func getHeight(): int
		ret me.height
	end func

	+func getPixel(x: int, y: int): @Rgba
		ret me.data[y][x]
	end func

	+func setPixel(x: int, y: int, d: @Rgba)
		do me.data[y][x] :: ##d
	end func
end class

+class Rgba()
	+var r: bit8
	+var g: bit8
	+var b: bit8
	+var a: bit8
	+func init(r: bit8, g: bit8, b: bit8, a: bit8): Rgba
		do me.r :: r
		do me.g :: g
		do me.b :: b
		do me.a :: a
		ret me
	end func
	*func cmp(t: kuin@Class): int
		var tt: @Rgba :: t $ @Rgba
		if(me.r = tt.r & me.g = tt.g & me.b = tt.b & me.a = tt.a)
			ret 0
		end if
		if(me.r > tt.r)
			ret 1
		end if
		if(me.r < tt.r)
			ret -1
		end if
		if(me.g > tt.g)
			ret 1
		end if
		if(me.g < tt.g)
			ret -1
		end if
		if(me.b > tt.b)
			ret 1
		end if
		if(me.b < tt.b)
			ret -1
		end if
		if(me.a > tt.a)
			ret 1
		end if
		if(me.a < tt.a)
			ret -1
		end if
		ret 0
	end func
end class

+enum Filetype
	bmp1bit
	bmp4bit
	bmp8bit
	bmp16bit
	bmp24bit
	bmp32bit
end enum
